# Requirements Document

## Introduction

Исправление race condition в функции обновления метаданных разговора. Текущая реализация использует паттерн read-modify-write без транзакции, что приводит к потере обновлений при конкурентном доступе.

## Glossary

- **Race Condition**: Ситуация, когда два или более процесса пытаются изменить общие данные одновременно, что приводит к непредсказуемым результатам
- **Transaction**: Атомарная операция базы данных, которая либо выполняется полностью, либо откатывается полностью
- **Optimistic Locking**: Стратегия контроля конкурентного доступа, при которой проверяется версия данных перед обновлением
- **Pessimistic Locking**: Стратегия контроля конкурентного доступа с использованием блокировок (SELECT FOR UPDATE)
- **Conversation Metadata**: JSON-поле в таблице conversation, содержащее дополнительные данные о разговоре

## Requirements

### Requirement 1

**User Story:** Как разработчик, я хочу безопасно обновлять метаданные разговора при конкурентном доступе, чтобы не терять данные при одновременных обновлениях.

#### Acceptance Criteria

1. WHEN два процесса одновременно обновляют метаданные разговора, THE System SHALL сохранить оба обновления без потери данных
2. WHEN обновление метаданных происходит, THE System SHALL использовать транзакцию базы данных для атомарности операции
3. WHEN происходит конфликт версий при оптимистичной блокировке, THE System SHALL повторить попытку обновления
4. THE System SHALL выполнять merge существующих метаданных с новыми данными внутри транзакции

### Requirement 2

**User Story:** Как разработчик, я хочу выбрать между оптимистичной и пессимистичной блокировкой, чтобы оптимизировать производительность для разных сценариев использования.

#### Acceptance Criteria

1. THE System SHALL поддерживать оптимистичную блокировку с использованием поля версии
2. THE System SHALL поддерживать пессимистичную блокировку с использованием SELECT FOR UPDATE
3. WHEN используется оптимистичная блокировка, THE System SHALL автоматически повторять попытку при конфликте версий
4. WHEN используется пессимистичная блокировка, THE System SHALL блокировать строку на время транзакции

### Requirement 3

**User Story:** Как разработчик, я хочу иметь обратную совместимость с существующим кодом, чтобы не ломать текущую функциональность.

#### Acceptance Criteria

1. THE System SHALL сохранить существующую сигнатуру функции updateConversationMetadata
2. THE System SHALL возвращать boolean результат операции (true/false)
3. WHEN обновление не удается после всех попыток, THE System SHALL возвращать false
4. THE System SHALL логировать ошибки с достаточной информацией для отладки

### Requirement 4

**User Story:** Как разработчик, я хочу настраивать количество повторных попыток, чтобы контролировать поведение при конфликтах.

#### Acceptance Criteria

1. THE System SHALL поддерживать конфигурируемое количество повторных попыток
2. WHEN достигнуто максимальное количество попыток, THE System SHALL возвращать false
3. THE System SHALL использовать разумное значение по умолчанию (например, 3 попытки)
4. WHEN происходит повторная попытка, THE System SHALL логировать информацию о конфликте

### Requirement 5

**User Story:** Как разработчик, я хочу минимизировать изменения в схеме базы данных, чтобы упростить миграцию.

#### Acceptance Criteria

1. IF используется оптимистичная блокировка, THEN THE System SHALL добавить поле metadata_version в таблицу conversation
2. THE System SHALL автоматически инициализировать metadata_version значением 1 для существующих записей
3. THE System SHALL инкрементировать metadata_version при каждом успешном обновлении
4. WHEN используется пессимистичная блокировка, THE System SHALL не требовать изменений схемы
