[config]
language = "ru"
verbosity_level = 1

[pr_description]
publish_description_as_comment = true
enable_pr_type = true
final_update_message = true

[pr_reviewer]
# Автоматический запуск при создании PR
auto_review = true
# Не запускать для черновиков
require_all_thresholds_for_incremental_review = false
# Включить оценку усилий для ревью
require_estimate_effort_to_review = true
# Включить проверку безопасности
require_security_review = true
# Включить проверку тестов
require_tests_review = true
# Отключить оценку времени разработки
require_estimate_contribution_time_cost = false
# Отключить проверку на возможность разделения PR
require_can_be_split_review = false
# Включить анализ тикетов
require_ticket_analysis_review = true
# Отключить сканирование TODO
require_todo_scan = false
# Отключить оценку PR
require_score_review = false
# Включить inline комментарии
inline_code_comments = true
# Количество inline комментариев
num_code_suggestions = 4

[pr_code_suggestions]
# Автоматические предложения по улучшению кода
auto_improve = false
num_code_suggestions = 4
summarize = true

[github]
# Публиковать как комментарий, а не как review
publish_output_progress = true

# Дополнительные инструкции для ревью по типам файлов
[pr_reviewer.extra_instructions]

"**/*.ts" = """
1. Именование и стиль кода:
   - Имена файлов должны использовать kebab-case (например: my-component.ts, user-profile.tsx)
   - Функции в camelCase, компоненты в PascalCase, константы в UPPER_SNAKE_CASE
   - Имена функций/методов должны четко отражать их назначение и реализацию
   - Соблюдать последовательность в стиле кода (отступы, пробелы, переносы строк)
   - Следовать принципам чистого кода (DRY, SOLID)
   - Использовать описательные имена переменных, объясняющие их назначение

2. TypeScript и типизация:
   - Использовать строгую типизацию и избегать any, unknown и {} где это возможно
   - Применять дженерики, интерфейсы и типы соответствующим образом
   - Обеспечить корректные определения типов для параметров функций и возвращаемых значений
   - Предпочитать объединение и пересечение типов сложным условным конструкциям
   - Использовать строгие проверки null и явно обрабатывать случаи undefined/null
   - Предпочитать утверждения типов приведению типов, когда это безопасно
   - Использовать брендированные типы для специфичных значений домена (ID, email и т.д.)

3. Соблюдение правил линтера:
   - Следовать правилам ESLint для React и TypeScript
   - Соблюдать руководящие принципы форматирования и анализа кода Biome
   - Обеспечить отсутствие предупреждений или ошибок линтера в коде
   - Использовать последовательный порядок импортов (внешние, внутренние, относительные)

4. Алгоритмы и производительность:
   - Писать понятные и читаемые алгоритмы, которые могут понять другие разработчики
   - Оптимизировать сложность алгоритмов (время и пространство)
   - Избегать чрезмерной вложенности и сложности
   - Правильно обрабатывать граничные случаи и ошибки
   - Использовать ранние возвраты для уменьшения вложенности
   - Предпочитать паттерны функционального программирования где это уместно

5. Безопасность и стабильность:
   - Реализовать правильную валидацию входных данных и защиту от инъекций
   - Правильно обрабатывать ошибки и исключения
   - Обеспечить безопасное хранение и передачу конфиденциальных данных
   - Использовать переменные окружения для конфиденциальной конфигурации
   - Валидировать все внешние входные данные с помощью схем Zod v4

6. Управление монорепозиторием:
   - Правильно использовать ссылки на рабочее пространство (пакеты @tecno/*)
   - Обеспечить правильное управление зависимостями между пакетами
   - Следовать последовательным паттернам во всех пакетах рабочего пространства

7. Пользовательский контент:
   - Обеспечить грамматическую корректность всего текста и сообщений
   - Убедиться, что весь текст, сообщения, комментарии и UI контент на русском языке
   - Отмечать любой нерусский текст, найденный в коде, комментариях или строковых литералах
"""

"**/*.tsx" = """
1. Именование и стиль кода:
   - Имена файлов должны использовать kebab-case (например: my-component.ts, user-profile.tsx)
   - Функции в camelCase, компоненты в PascalCase, константы в UPPER_SNAKE_CASE
   - Имена функций/методов должны четко отражать их назначение и реализацию
   - Соблюдать последовательность в стиле кода (отступы, пробелы, переносы строк)
   - Следовать принципам чистого кода (DRY, SOLID)

2. TypeScript и типизация:
   - Использовать строгую типизацию и избегать any, unknown и {} где это возможно
   - Применять дженерики, интерфейсы и типы соответствующим образом
   - Обеспечить корректные определения типов для параметров функций и возвращаемых значений
   - Определять правильные типы props для всех React компонентов
   - Использовать брендированные типы для специфичных значений домена

3. Лучшие практики React и Next.js:
   - Оптимизировать React компоненты (использовать мемоизацию, поддерживать правильную структуру)
   - Правильно использовать хуки (useEffect, useState, useCallback, useMemo)
   - Предотвращать утечки памяти в useEffect с правильной очисткой
   - Правильно реализовывать серверные и клиентские компоненты в Next.js
   - Оптимизировать стратегии маршрутизации и загрузки данных (SSR, SSG, ISR)
   - Использовать правильные границы ошибок для обработки ошибок
   - Реализовывать правильные состояния загрузки и ошибок
   - Использовать React.forwardRef для компонентов, которым нужна передача ref
   - Предпочитать композицию наследованию
   - Использовать правильные key props в списках

4. Управление состоянием и получение данных:
   - Использовать TanStack Query для управления состоянием сервера
   - Реализовывать правильные стратегии кэширования
   - Правильно обрабатывать оптимистические обновления
   - Использовать правильную обработку ошибок для асинхронных операций

5. Соблюдение правил линтера:
   - Следовать правилам ESLint для React и TypeScript
   - Соблюдать руководящие принципы форматирования и анализа кода Biome
   - Обеспечить отсутствие предупреждений или ошибок линтера в коде

6. Безопасность и стабильность:
   - Реализовать правильную валидацию входных данных и защиту от инъекций
   - Правильно обрабатывать ошибки и исключения
   - Обеспечить безопасное хранение и передачу конфиденциальных данных
   - Валидировать все внешние входные данные с помощью схем Zod v4
   - Очищать пользовательский контент (используя dompurify)

7. Доступность и UX:
   - Реализовывать правильные ARIA метки и роли
   - Обеспечить правильную работу навигации с клавиатуры
   - Использовать семантические HTML элементы
   - Реализовывать правильное управление фокусом
   - Обеспечить достаточный цветовой контраст
   - Поддерживать программы чтения с экрана

8. Управление монорепозиторием:
   - Правильно использовать ссылки на рабочее пространство (пакеты @tecno/*)
   - Обеспечить правильное управление зависимостями между пакетами

9. Пользовательский контент:
   - Обеспечить грамматическую корректность всего текста и сообщений
   - Убедиться, что весь текст, сообщения, комментарии и UI контент на русском языке
   - Отмечать любой нерусский текст, найденный в коде, комментариях или строковых литералах
"""

"**/*.json" = """
1. Структура и форматирование JSON:
   - Обеспечить правильный синтаксис JSON и валидную структуру
   - Использовать последовательные отступы (2 пробела)
   - Поддерживать алфавитный порядок ключей где это логично
   - Использовать осмысленные и описательные имена свойств

2. Специфика Package.json:
   - Следовать семантическому версионированию для номеров версий
   - Правильно использовать ссылки на рабочее пространство (workspace:*)
   - Обеспечить правильную категоризацию всех зависимостей (dependencies vs devDependencies)
   - Включать правильные скрипты с понятными названиями
   - Использовать только bun, не npm

3. Конфигурационные файлы:
   - Обеспечить присутствие всех обязательных полей
   - Использовать конфигурации для разных сред соответствующим образом
   - Валидировать схемы конфигурации
"""

"**/*.md" = """
1. Форматирование Markdown:
   - Использовать последовательную иерархию заголовков (# ## ### и т.д.)
   - Обеспечить правильное форматирование ссылок и валидные URL
   - Использовать блоки кода с соответствующей спецификацией языка
   - Поддерживать последовательное форматирование списков

2. Качество документации:
   - Писать ясные и краткие объяснения
   - Включать практические примеры где это уместно
   - Поддерживать документацию актуальной относительно изменений в коде
   - Использовать правильную грамматику и орфографию
   - Структурировать контент логично с понятными разделами

3. README файлы:
   - Включать понятное описание и назначение проекта
   - Предоставлять инструкции по установке и настройке
   - Документировать доступные скрипты и команды
"""

"**/Dockerfile" = """
1. Лучшие практики Docker:
   - Использовать официальные базовые образы когда это возможно
   - Минимизировать количество слоев
   - Использовать многоэтапные сборки для оптимизации
   - Устанавливать правильные рабочие директории
   - Использовать не-root пользователей для безопасности

2. Безопасность и оптимизация:
   - Закреплять конкретные версии для воспроизводимых сборок
   - Удалять ненужные пакеты и файлы
   - Использовать .dockerignore для исключения ненужных файлов
   - Устанавливать правильные переменные окружения
   - Реализовывать правильные проверки состояния
"""

"**/*.css" = """
1. Структура и организация CSS:
   - Использовать последовательные соглашения по именованию (BEM или аналогичные)
   - Организовывать стили логично (базовые, компоненты, утилиты)
   - Использовать пользовательские CSS свойства для тематизации
   - Обеспечить правильную иерархию специфичности

2. Производительность и поддерживаемость:
   - Избегать глубокой вложенности (максимум 3-4 уровня)
   - Использовать эффективные селекторы
   - Минимизировать использование !important
   - Обеспечить кроссбраузерную совместимость
"""

"**/tailwind.config.*" = """
1. Конфигурация Tailwind:
   - Организовывать расширения темы логично
   - Использовать последовательные названия для пользовательских утилит
   - Обеспечить правильную конфигурацию purge/content
   - Документировать пользовательские конфигурации

2. Последовательность дизайн-системы:
   - Поддерживать последовательную шкалу отступов
   - Использовать семантические названия цветов
   - Обеспечить доступность в выборе цветов
"""

"**/turbo.json" = """
1. Конфигурация Turbo:
   - Определять понятные зависимости задач
   - Использовать соответствующие стратегии кэширования
   - Обеспечить правильные спецификации входных/выходных данных
   - Оптимизировать конвейер для параллельного выполнения

2. Оптимизация монорепозитория:
   - Настроить правильную фильтрацию рабочего пространства
   - Правильно использовать обработку переменных окружения
   - Обеспечить последовательное именование задач во всех пакетах
"""

"**/.env*" = """
1. Переменные окружения:
   - Использовать описательные имена переменных с последовательными префиксами
   - Группировать связанные переменные вместе
   - Включать комментарии, объясняющие назначение сложных переменных
   - Никогда не коммитить реальные секреты (использовать .env.example)

2. Соображения безопасности:
   - Использовать сильные, уникальные значения для секретов
   - Регулярно ротировать секреты
   - Использовать соответствующие области видимости (разработка, staging, продакшн)
"""
